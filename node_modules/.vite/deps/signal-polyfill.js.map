{
  "version": 3,
  "sources": ["../../signal-polyfill/dist/index.js"],
  "sourcesContent": ["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateIn = (member, obj) => {\n  if (Object(obj) !== obj)\n    throw TypeError('Cannot use the \"in\" operator on this value');\n  return member.has(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\nlet epoch = 1;\nconst SIGNAL = /* @__PURE__ */ Symbol(\"SIGNAL\");\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producerNode: void 0,\n  producerLastReadVersion: void 0,\n  producerIndexOfThis: void 0,\n  nextProducerIndex: 0,\n  liveConsumerNode: void 0,\n  liveConsumerIndexOfThis: void 0,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {\n  },\n  consumerMarkedDirty: () => {\n  },\n  consumerOnSignalRead: () => {\n  }\n};\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(\n      typeof ngDevMode !== \"undefined\" && ngDevMode ? `Assertion error: signal read during notification phase` : \"\"\n    );\n  }\n  if (activeConsumer === null) {\n    return;\n  }\n  activeConsumer.consumerOnSignalRead(node);\n  const idx = activeConsumer.nextProducerIndex++;\n  assertConsumerNode(activeConsumer);\n  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode[idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n    }\n  }\n  if (activeConsumer.producerNode[idx] !== node) {\n    activeConsumer.producerNode[idx] = node;\n    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n  }\n  activeConsumer.producerLastReadVersion[idx] = node.version;\n}\nfunction producerIncrementEpoch() {\n  epoch++;\n}\nfunction producerUpdateValueVersion(node) {\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n    return;\n  }\n  node.producerRecomputeValue(node);\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\nfunction producerNotifyConsumers(node) {\n  if (node.liveConsumerNode === void 0) {\n    return;\n  }\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\nfunction producerUpdatesAllowed() {\n  return (activeConsumer == null ? void 0 : activeConsumer.consumerAllowSignalWrites) !== false;\n}\nfunction consumerMarkDirty(node) {\n  var _a;\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  (_a = node.consumerMarkedDirty) == null ? void 0 : _a.call(node.wrapper ?? node);\n}\nfunction consumerBeforeComputation(node) {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {\n    return;\n  }\n  if (consumerIsLive(node)) {\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion.pop();\n    node.producerIndexOfThis.pop();\n  }\n}\nfunction consumerPollProducersForChange(node) {\n  assertConsumerNode(node);\n  for (let i = 0; i < node.producerNode.length; i++) {\n    const producer = node.producerNode[i];\n    const seenVersion = node.producerLastReadVersion[i];\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    producerUpdateValueVersion(producer);\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n  var _a;\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (node.liveConsumerNode.length === 0) {\n    (_a = node.watched) == null ? void 0 : _a.call(node.wrapper);\n    for (let i = 0; i < node.producerNode.length; i++) {\n      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n    }\n  }\n  node.liveConsumerIndexOfThis.push(indexOfThis);\n  return node.liveConsumerNode.push(consumer) - 1;\n}\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n  var _a;\n  assertProducerNode(node);\n  assertConsumerNode(node);\n  if (typeof ngDevMode !== \"undefined\" && ngDevMode && idx >= node.liveConsumerNode.length) {\n    throw new Error(\n      `Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`\n    );\n  }\n  if (node.liveConsumerNode.length === 1) {\n    (_a = node.unwatched) == null ? void 0 : _a.call(node.wrapper);\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  const lastIdx = node.liveConsumerNode.length - 1;\n  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n  node.liveConsumerNode.length--;\n  node.liveConsumerIndexOfThis.length--;\n  if (idx < node.liveConsumerNode.length) {\n    const idxProducer = node.liveConsumerIndexOfThis[idx];\n    const consumer = node.liveConsumerNode[idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis[idxProducer] = idx;\n  }\n}\nfunction consumerIsLive(node) {\n  var _a;\n  return node.consumerIsAlwaysLive || (((_a = node == null ? void 0 : node.liveConsumerNode) == null ? void 0 : _a.length) ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n  node.producerNode ?? (node.producerNode = []);\n  node.producerIndexOfThis ?? (node.producerIndexOfThis = []);\n  node.producerLastReadVersion ?? (node.producerLastReadVersion = []);\n}\nfunction assertProducerNode(node) {\n  node.liveConsumerNode ?? (node.liveConsumerNode = []);\n  node.liveConsumerIndexOfThis ?? (node.liveConsumerIndexOfThis = []);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction computedGet(node) {\n  producerUpdateValueVersion(node);\n  producerAccessed(node);\n  if (node.value === ERRORED) {\n    throw node.error;\n  }\n  return node.value;\n}\nfunction createComputed(computation) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  const computed = () => computedGet(node);\n  computed[SIGNAL] = node;\n  return computed;\n}\nconst UNSET = /* @__PURE__ */ Symbol(\"UNSET\");\nconst COMPUTING = /* @__PURE__ */ Symbol(\"COMPUTING\");\nconst ERRORED = /* @__PURE__ */ Symbol(\"ERRORED\");\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(\"Detected cycle in computations.\");\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      let wasEqual = false;\n      try {\n        newValue = node.computation.call(node.wrapper);\n        const oldOk = oldValue !== UNSET && oldValue !== ERRORED;\n        wasEqual = oldOk && node.equal.call(node.wrapper, oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (wasEqual) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction createSignal(initialValue) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  const getter = () => {\n    producerAccessed(node);\n    return node.value;\n  };\n  getter[SIGNAL] = node;\n  return getter;\n}\nfunction signalGetFn() {\n  producerAccessed(this);\n  return this.value;\n}\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError();\n  }\n  if (!node.equal.call(node.wrapper, node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: void 0\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n}\n/**\n * @license\n * Copyright 2024 Bloomberg Finance L.P.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst NODE = Symbol(\"node\");\nvar Signal;\n((Signal2) => {\n  var _a, _brand, brand_fn, _b, _brand2, brand_fn2;\n  class State {\n    constructor(initialValue, options = {}) {\n      __privateAdd(this, _brand);\n      __publicField(this, _a);\n      const ref = createSignal(initialValue);\n      const node = ref[SIGNAL];\n      this[NODE] = node;\n      node.wrapper = this;\n      if (options) {\n        const equals = options.equals;\n        if (equals) {\n          node.equal = equals;\n        }\n        node.watched = options[Signal2.subtle.watched];\n        node.unwatched = options[Signal2.subtle.unwatched];\n      }\n    }\n    get() {\n      if (!(0, Signal2.isState)(this))\n        throw new TypeError(\"Wrong receiver type for Signal.State.prototype.get\");\n      return signalGetFn.call(this[NODE]);\n    }\n    set(newValue) {\n      if (!(0, Signal2.isState)(this))\n        throw new TypeError(\"Wrong receiver type for Signal.State.prototype.set\");\n      if (isInNotificationPhase()) {\n        throw new Error(\"Writes to signals not permitted during Watcher callback\");\n      }\n      const ref = this[NODE];\n      signalSetFn(ref, newValue);\n    }\n  }\n  _a = NODE;\n  _brand = new WeakSet();\n  brand_fn = function() {\n  };\n  Signal2.isState = (s) => typeof s === \"object\" && __privateIn(_brand, s);\n  Signal2.State = State;\n  class Computed {\n    // Create a Signal which evaluates to the value returned by the callback.\n    // Callback is called with this signal as the parameter.\n    constructor(computation, options) {\n      __privateAdd(this, _brand2);\n      __publicField(this, _b);\n      const ref = createComputed(computation);\n      const node = ref[SIGNAL];\n      node.consumerAllowSignalWrites = true;\n      this[NODE] = node;\n      node.wrapper = this;\n      if (options) {\n        const equals = options.equals;\n        if (equals) {\n          node.equal = equals;\n        }\n        node.watched = options[Signal2.subtle.watched];\n        node.unwatched = options[Signal2.subtle.unwatched];\n      }\n    }\n    get() {\n      if (!(0, Signal2.isComputed)(this))\n        throw new TypeError(\"Wrong receiver type for Signal.Computed.prototype.get\");\n      return computedGet(this[NODE]);\n    }\n  }\n  _b = NODE;\n  _brand2 = new WeakSet();\n  brand_fn2 = function() {\n  };\n  Signal2.isComputed = (c) => typeof c === \"object\" && __privateIn(_brand2, c);\n  Signal2.Computed = Computed;\n  ((subtle2) => {\n    var _a2, _brand3, brand_fn3, _assertSignals, assertSignals_fn;\n    function untrack(cb) {\n      let output;\n      let prevActiveConsumer = null;\n      try {\n        prevActiveConsumer = setActiveConsumer(null);\n        output = cb();\n      } finally {\n        setActiveConsumer(prevActiveConsumer);\n      }\n      return output;\n    }\n    subtle2.untrack = untrack;\n    function introspectSources(sink) {\n      var _a3;\n      if (!(0, Signal2.isComputed)(sink) && !(0, Signal2.isWatcher)(sink)) {\n        throw new TypeError(\"Called introspectSources without a Computed or Watcher argument\");\n      }\n      return ((_a3 = sink[NODE].producerNode) == null ? void 0 : _a3.map((n) => n.wrapper)) ?? [];\n    }\n    subtle2.introspectSources = introspectSources;\n    function introspectSinks(signal) {\n      var _a3;\n      if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isState)(signal)) {\n        throw new TypeError(\"Called introspectSinks without a Signal argument\");\n      }\n      return ((_a3 = signal[NODE].liveConsumerNode) == null ? void 0 : _a3.map((n) => n.wrapper)) ?? [];\n    }\n    subtle2.introspectSinks = introspectSinks;\n    function hasSinks(signal) {\n      if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isState)(signal)) {\n        throw new TypeError(\"Called hasSinks without a Signal argument\");\n      }\n      const liveConsumerNode = signal[NODE].liveConsumerNode;\n      if (!liveConsumerNode)\n        return false;\n      return liveConsumerNode.length > 0;\n    }\n    subtle2.hasSinks = hasSinks;\n    function hasSources(signal) {\n      if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isWatcher)(signal)) {\n        throw new TypeError(\"Called hasSources without a Computed or Watcher argument\");\n      }\n      const producerNode = signal[NODE].producerNode;\n      if (!producerNode)\n        return false;\n      return producerNode.length > 0;\n    }\n    subtle2.hasSources = hasSources;\n    class Watcher {\n      // When a (recursive) source of Watcher is written to, call this callback,\n      // if it hasn't already been called since the last `watch` call.\n      // No signals may be read or written during the notify.\n      constructor(notify) {\n        __privateAdd(this, _brand3);\n        __privateAdd(this, _assertSignals);\n        __publicField(this, _a2);\n        let node = Object.create(REACTIVE_NODE);\n        node.wrapper = this;\n        node.consumerMarkedDirty = notify;\n        node.consumerIsAlwaysLive = true;\n        node.consumerAllowSignalWrites = false;\n        node.producerNode = [];\n        this[NODE] = node;\n      }\n      // Add these signals to the Watcher's set, and set the watcher to run its\n      // notify callback next time any signal in the set (or one of its dependencies) changes.\n      // Can be called with no arguments just to reset the \"notified\" state, so that\n      // the notify callback will be invoked again.\n      watch(...signals) {\n        if (!(0, Signal2.isWatcher)(this)) {\n          throw new TypeError(\"Called unwatch without Watcher receiver\");\n        }\n        __privateMethod(this, _assertSignals, assertSignals_fn).call(this, signals);\n        const node = this[NODE];\n        node.dirty = false;\n        const prev = setActiveConsumer(node);\n        for (const signal of signals) {\n          producerAccessed(signal[NODE]);\n        }\n        setActiveConsumer(prev);\n      }\n      // Remove these signals from the watched set (e.g., for an effect which is disposed)\n      unwatch(...signals) {\n        if (!(0, Signal2.isWatcher)(this)) {\n          throw new TypeError(\"Called unwatch without Watcher receiver\");\n        }\n        __privateMethod(this, _assertSignals, assertSignals_fn).call(this, signals);\n        const node = this[NODE];\n        assertConsumerNode(node);\n        for (let i = node.producerNode.length - 1; i >= 0; i--) {\n          if (signals.includes(node.producerNode[i].wrapper)) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n            const lastIdx = node.producerNode.length - 1;\n            node.producerNode[i] = node.producerNode[lastIdx];\n            node.producerIndexOfThis[i] = node.producerIndexOfThis[lastIdx];\n            node.producerNode.length--;\n            node.producerIndexOfThis.length--;\n            node.nextProducerIndex--;\n            if (i < node.producerNode.length) {\n              const idxConsumer = node.producerIndexOfThis[i];\n              const producer = node.producerNode[i];\n              assertProducerNode(producer);\n              producer.liveConsumerIndexOfThis[idxConsumer] = i;\n            }\n          }\n        }\n      }\n      // Returns the set of computeds in the Watcher's set which are still yet\n      // to be re-evaluated\n      getPending() {\n        if (!(0, Signal2.isWatcher)(this)) {\n          throw new TypeError(\"Called getPending without Watcher receiver\");\n        }\n        const node = this[NODE];\n        return node.producerNode.filter((n) => n.dirty).map((n) => n.wrapper);\n      }\n    }\n    _a2 = NODE;\n    _brand3 = new WeakSet();\n    brand_fn3 = function() {\n    };\n    _assertSignals = new WeakSet();\n    assertSignals_fn = function(signals) {\n      for (const signal of signals) {\n        if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isState)(signal)) {\n          throw new TypeError(\"Called watch/unwatch without a Computed or State argument\");\n        }\n      }\n    };\n    Signal2.isWatcher = (w) => __privateIn(_brand3, w);\n    subtle2.Watcher = Watcher;\n    function currentComputed() {\n      var _a3;\n      return (_a3 = getActiveConsumer()) == null ? void 0 : _a3.wrapper;\n    }\n    subtle2.currentComputed = currentComputed;\n    subtle2.watched = Symbol(\"watched\");\n    subtle2.unwatched = Symbol(\"unwatched\");\n  })(Signal2.subtle || (Signal2.subtle = {}));\n})(Signal || (Signal = {}));\nexport {\n  Signal\n};\n"],
  "mappings": "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",
  "names": []
}
